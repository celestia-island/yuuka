# Yuuka - Введение

**Yuuka** — это библиотека процедурных макросов Rust, которая позволяет определять сложные, глубоко вложенные иерархии структур и перечислений с помощью лаконичного DSL-синтаксиса, напоминающего JSON. Она построена на основе `serde` для бесшовной сериализации и десериализации.

## Установка

Добавьте следующее в ваш `Cargo.toml`:

```toml
[dependencies]
yuuka = "0.6"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
```

> `serde` и `serde_json` являются необязательными, но часто используются вместе с yuuka для поддержки сериализации.

## Основные макросы

Yuuka экспортирует три процедурных макроса:

| Макрос | Назначение |
| --- | --- |
| [`derive_struct!`](./derive-struct.md) | Определение вложенных иерархий структур с помощью JSON-подобного DSL |
| [`derive_enum!`](./derive-enum.md) | Определение перечислений с различными формами вариантов |
| [`auto!`](./auto-macro.md) | Конструирование экземпляров типов, сгенерированных вышеуказанными макросами, с упрощённым синтаксисом |

Смотрите также:

- [Атрибуты и видимость](./attributes.md) — дополнительные derive-макросы, распространение атрибутов, управление видимостью и межкрейтовое использование
- [Примеры](./examples.md) — реальные примеры использования и структура сгенерированного кода

## Быстрый старт

```rust
use serde::{Serialize, Deserialize};
use yuuka::{derive_struct, auto};

derive_struct!(
    #[derive(PartialEq, Serialize, Deserialize)]
    GameConfig {
        title: String,
        window: Window {
            width: u32,
            height: u32,
            fullscreen: bool,
        },
        plugins: [Plugin {
            name: String,
            enabled: bool,
        }],
    }
);

let config = auto!(GameConfig {
    title: "My Game".to_string(),
    window: {
        width: 1920,
        height: 1080,
        fullscreen: true,
    },
    plugins: vec![
        Plugin {
            name: "Audio".to_string(),
            enabled: true,
        },
    ],
});
```

Один вызов `derive_struct!` автоматически генерирует три независимые структуры — `GameConfig`, `Window` и `Plugin` — все с `#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]`. Макрос `auto!` затем позволяет конструировать экземпляры, используя блоки `{ }` для анонимных/встроенных подструктур без необходимости знать их сгенерированные имена.

## Указатель документации

| Документ | Описание |
| --- | --- |
| [derive_struct!](./derive-struct.md) | Макрос определения структур — вложенные структуры, анонимные структуры, типы Vec/Option, значения по умолчанию, встроенные перечисления, ссылочные типы |
| [derive_enum!](./derive-enum.md) | Макрос определения перечислений — unit/struct/tuple варианты, вложенные перечисления, значения по умолчанию |
| [auto!](./auto-macro.md) | Макрос конструирования экземпляров — упрощённый синтаксис для анонимных типов, пути перечислений, spread-выражения |
| [Атрибуты и видимость](./attributes.md) | Derive-макросы, распространение атрибутов, `#[macros_recursive]`, атрибуты уровня поля, видимость, `#[macro_export]`, межкрейтовое использование |
| [Примеры](./examples.md) | Реальные примеры использования, объяснение структуры сгенерированного кода |
