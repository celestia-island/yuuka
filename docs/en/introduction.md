# Yuuka - Introduction

**Yuuka** is a Rust procedural macro library that lets you define complex, deeply nested struct and enum hierarchies using a concise, JSON-like DSL syntax. It is built on top of `serde` for seamless serialization and deserialization.

## Installation

Add the following to your `Cargo.toml`:

```toml
[dependencies]
yuuka = "0.6"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
```

> `serde` and `serde_json` are optional but commonly used alongside yuuka for serialization support.

## Core Macros

Yuuka exports three procedural macros:

| Macro | Purpose |
| --- | --- |
| [`derive_struct!`](./derive-struct.md) | Define nested struct hierarchies with a JSON-like DSL |
| [`derive_enum!`](./derive-enum.md) | Define enum types with various variant forms |
| [`auto!`](./auto-macro.md) | Construct instances of types generated by the above macros with simplified syntax |

See also:

- [Attributes & Visibility](./attributes.md) — Extra derive macros, attribute propagation, visibility control, and cross-crate usage
- [Examples](./examples.md) — Real-world examples and generated code structure

## Quick Start

```rust
use serde::{Serialize, Deserialize};
use yuuka::{derive_struct, auto};

derive_struct!(
    #[derive(PartialEq, Serialize, Deserialize)]
    GameConfig {
        title: String,
        window: Window {
            width: u32,
            height: u32,
            fullscreen: bool,
        },
        plugins: [Plugin {
            name: String,
            enabled: bool,
        }],
    }
);

let config = auto!(GameConfig {
    title: "My Game".to_string(),
    window: {
        width: 1920,
        height: 1080,
        fullscreen: true,
    },
    plugins: vec![
        Plugin {
            name: "Audio".to_string(),
            enabled: true,
        },
    ],
});
```

This single `derive_struct!` call automatically generates three independent structs — `GameConfig`, `Window`, and `Plugin` — all with `#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]`. The `auto!` macro then allows constructing instances using `{ }` blocks for anonymous/inline sub-structs without knowing their generated names.

## Documentation Index

| Document | Description |
| --- | --- |
| [derive_struct!](./derive-struct.md) | Struct definition macro — nested structs, anonymous structs, Vec/Option types, default values, inline enums, reference types |
| [derive_enum!](./derive-enum.md) | Enum definition macro — unit/struct/tuple variants, nested enums, default values |
| [auto!](./auto-macro.md) | Instance construction macro — simplified syntax for anonymous types, enum paths, spread expressions |
| [Attributes & Visibility](./attributes.md) | Derive macros, attribute propagation, `#[macros_recursive]`, field-level attributes, visibility, `#[macro_export]`, cross-crate usage |
| [Examples](./examples.md) | Real-world examples, generated code structure explanation |
